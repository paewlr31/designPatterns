---
Jednostronicowa notatka – wybrane wzorce dla biblioteki permutacji

Kontekst: biblioteka Pythona do generowania permutacji, dzielenia przestrzeni zadań i konfiguracji generatorów; aplikacja demonstracyjna (np. łamanie hashy) korzysta z biblioteki, ale sama logika rozproszona jest opcjonalna.


---

Wybrane wzorce

1. Strategy – elastyczne algorytmy generowania permutacji i podziału przestrzeni

Rola: definiuje różne sposoby generowania kandydatów: BruteForceStrategy, DictionaryStrategy, MaskStrategy; oraz strategie przydziału podprzestrzeni (FixedChunk, AdaptiveChunk).

Dlaczego: pozwala wymieniać algorytmy w czasie działania, testować i rozszerzać bibliotekę bez zmian w kodzie aplikacji.

Korzyść: elastyczność i skalowalność.



---

2. Iterator – leniwe przeglądanie permutacji

Rola: umożliwia generowanie kandydatów jeden po drugim bez tworzenia całej przestrzeni w pamięci.

Dlaczego: przestrzeń permutacji jest ogromna (np. 62^7 kombinacji), więc leniwy iterator jest konieczny dla efektywności.

Korzyść: oszczędność pamięci, możliwość przetwarzania strumieniowego i dzielenia przestrzeni na paczki.



---

3. Builder – konfiguracja generatorów permutacji

Rola: pozwala krok po kroku ustawić parametry generatora (alfabet, długość, maski, tryb strategii).

Dlaczego: generator może mieć wiele parametrów, więc Builder ułatwia czytelne i skalowalne tworzenie obiektów.

Korzyść: przejrzyste API, łatwa rozszerzalność, minimalizuje liczbę konstruktorów.



---

4. Abstract Factory – tworzenie rodzin generatorów

Rola: dostarcza interfejs do tworzenia powiązanych generatorów i strategii bez ujawniania szczegółów implementacji.

Dlaczego: jeśli potrzebujemy różnych rodzin generatorów (np. do permutacji znaków, liczb, maski), Abstract Factory pozwala łatwo je wymieniać w projekcie.

Korzyść: spójność konfiguracji, łatwe rozszerzanie i integracja z różnymi typami generatorów.



---

Dlaczego te, a nie inne wzorce

Wybrane: Strategy, Iterator, Builder, Abstract Factory

Pasują do biblioteki, bo zapewniają elastyczność, skalowalność i testowalność w samym silniku permutacji i podziału przestrzeni zadań.


Odrzucone:

Command i Observer – służą głównie aplikacji rozproszonej, nie samej bibliotece.

Singleton – ewentualny detal implementacyjny (logger/manager), nie kluczowa architektura.

Template Method, Visitor, Adapter – mniej naturalne w kontekście generowania permutacji i konfiguracji generatorów.

Repository, Data Mapper, Active Record – dotyczą trwałych danych i DB; tutaj operujemy na pamięci i strukturach czasowych.



---

Podsumowanie przepływu w bibliotece

1. Builder/Abstract Factory tworzy odpowiedni generator permutacji z parametrami.


2. Strategy wybiera algorytm generowania kandydatów i ewentualnie sposób dzielenia przestrzeni.


3. Iterator umożliwia leniwe przeglądanie kolejnych kandydatów, wspierając dzielenie zadań i skalowalność.



Efekt: elastyczna, ogólna i łatwa do rozszerzenia biblioteka permutacji, którą aplikacja demonstracyjna może wykorzystać do różnych celów (np. łamania hashy).


---

Przygotować diagram klas + krótki schemat przepływu dla tych wzorców, żeby była gotowa do prezentacji na slajdzie.
